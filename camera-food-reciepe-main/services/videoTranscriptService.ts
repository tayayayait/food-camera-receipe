export interface TranscriptSegment {
  text: string;
  start?: number;
  duration?: number;
}

export type VideoTranscriptStatus = 'available' | 'autoGenerated' | 'unavailable';

export interface TranscriptFetchSuccess {
  status: Extract<VideoTranscriptStatus, 'available' | 'autoGenerated'>;
  videoId: string;
  segments: TranscriptSegment[];
}

export interface TranscriptFallbackResult {
  status: Extract<VideoTranscriptStatus, 'autoGenerated'>;
  segments: TranscriptSegment[];
  reason?: string;
}

export interface TranscriptFetchUnavailable {
  status: Extract<VideoTranscriptStatus, 'unavailable'>;
  videoId: string;
  reason?: string;
}

export type TranscriptFetchResult = TranscriptFetchSuccess | TranscriptFetchUnavailable;

const DEFAULT_TRANSCRIPT_ENDPOINT = '/api/transcript';
const DEFAULT_TRANSCRIPT_FALLBACK_ENDPOINT = '/api/transcript/fallback';

const resolveTranscriptEndpoint = () =>
  (process.env.VIDEO_TRANSCRIPT_SERVICE_URL as string | undefined) ?? DEFAULT_TRANSCRIPT_ENDPOINT;

const resolveTranscriptFallbackEndpoint = () =>
  (process.env.VIDEO_TRANSCRIPT_FALLBACK_SERVICE_URL as string | undefined) ??
  DEFAULT_TRANSCRIPT_FALLBACK_ENDPOINT;

const YOUTUBE_ID_REGEX = /^[a-zA-Z0-9_-]{11}$/;

const extractYoutubeIdFromUrl = (candidate: string): string | null => {
  try {
    const parsed = new URL(candidate);
    if (parsed.hostname === 'youtu.be') {
      const id = parsed.pathname.replace(/^\/+/, '');
      return YOUTUBE_ID_REGEX.test(id) ? id : null;
    }

    if (parsed.hostname.endsWith('youtube.com')) {
      if (parsed.pathname.startsWith('/embed/')) {
        const id = parsed.pathname.split('/')[2];
        return id && YOUTUBE_ID_REGEX.test(id) ? id : null;
      }

      const id = parsed.searchParams.get('v');
      if (id && YOUTUBE_ID_REGEX.test(id)) {
        return id;
      }
    }
  } catch {
    // Ignore parsing errors â€“ fall back to plain ID checks below.
  }

  return null;
};

export const resolveYoutubeVideoId = (candidate: string): string | null => {
  if (!candidate) {
    return null;
  }

  const trimmed = candidate.trim();
  if (YOUTUBE_ID_REGEX.test(trimmed)) {
    return trimmed;
  }

  return extractYoutubeIdFromUrl(trimmed);
};

const normalizeSegments = (segments: unknown): TranscriptSegment[] => {
  if (!Array.isArray(segments)) {
    return [];
  }

  return segments
    .map(segment => {
      if (!segment || typeof segment !== 'object') {
        return null;
      }

      const text = 'text' in segment ? String((segment as { text?: unknown }).text ?? '').trim() : '';
      if (!text) {
        return null;
      }

      const startRaw = (segment as { start?: unknown }).start;
      const durationRaw = (segment as { duration?: unknown }).duration;

      const parsedSegment: TranscriptSegment = { text };

      if (typeof startRaw === 'number' && Number.isFinite(startRaw)) {
        parsedSegment.start = startRaw;
      }

      if (typeof durationRaw === 'number' && Number.isFinite(durationRaw)) {
        parsedSegment.duration = durationRaw;
      }

      return parsedSegment;
    })
    .filter((segment): segment is TranscriptSegment => Boolean(segment));
};

export async function fetchVideoTranscriptFallback(candidate: string): Promise<TranscriptFallbackResult | null> {
  const videoId = resolveYoutubeVideoId(candidate);

  if (!videoId) {
    throw new Error('error_transcript_invalid_video');
  }

  const endpoint = resolveTranscriptFallbackEndpoint();

  let response: Response;
  try {
    response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ videoId }),
    });
  } catch (error) {
    console.error('Failed to reach fallback transcript service', error);
    return null;
  }

  if (response.status === 404) {
    return { status: 'autoGenerated', segments: [], reason: 'fallback_not_found' };
  }

  if (!response.ok) {
    console.error('Fallback transcript service returned an error', response.status, response.statusText);
    return null;
  }

  let payload: unknown;
  try {
    payload = await response.json();
  } catch (error) {
    console.error('Fallback transcript service returned invalid JSON', error);
    return null;
  }

  const segments = normalizeSegments((payload as { segments?: unknown } | undefined)?.segments);
  const reasonRaw = (payload as { reason?: unknown } | undefined)?.reason;

  return {
    status: 'autoGenerated',
    segments,
    reason: typeof reasonRaw === 'string' ? reasonRaw : undefined,
  };
}

const attemptFallbackTranscript = async (
  videoId: string,
  fallbackReason?: string
): Promise<TranscriptFetchResult> => {
  let fallbackResult: TranscriptFallbackResult | null = null;

  try {
    fallbackResult = await fetchVideoTranscriptFallback(videoId);
  } catch (error) {
    console.error('Fallback transcript attempt failed', error);
    fallbackResult = null;
  }

  if (fallbackResult && fallbackResult.segments.length > 0) {
    return {
      status: fallbackResult.status,
      videoId,
      segments: fallbackResult.segments,
    };
  }

  return {
    status: 'unavailable',
    videoId,
    reason: fallbackResult?.reason ?? fallbackReason,
  };
};

export async function fetchVideoTranscript(candidate: string): Promise<TranscriptFetchResult> {
  const videoId = resolveYoutubeVideoId(candidate);

  if (!videoId) {
    throw new Error('error_transcript_invalid_video');
  }

  const endpoint = resolveTranscriptEndpoint();
  const url = `${endpoint}?videoId=${encodeURIComponent(videoId)}`;

  let response: Response;
  try {
    response = await fetch(url);
  } catch (error) {
    console.error('Failed to reach transcript service', error);
    throw new Error('error_transcript_fetch');
  }

  if (response.status === 404) {
    return attemptFallbackTranscript(videoId);
  }

  if (!response.ok) {
    console.error('Transcript service returned an error', response.status, response.statusText);
    throw new Error('error_transcript_fetch');
  }

  let payload: unknown;
  try {
    payload = await response.json();
  } catch (error) {
    console.error('Transcript service returned invalid JSON', error);
    throw new Error('error_transcript_fetch');
  }

  const segments = normalizeSegments((payload as { segments?: unknown } | undefined)?.segments);

  if (segments.length === 0) {
    const reason = (payload as { reason?: unknown } | undefined)?.reason;
    return attemptFallbackTranscript(
      videoId,
      typeof reason === 'string' ? reason : undefined
    );
  }

  const isAutoGeneratedRaw = (payload as { isAutoGenerated?: unknown } | undefined)?.isAutoGenerated;
  const status: TranscriptFetchResult['status'] = isAutoGeneratedRaw ? 'autoGenerated' : 'available';

  return {
    status,
    videoId,
    segments,
  };
}
