import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

const fetchVideoTranscriptMock = vi.fn();
const fetchVideoTranscriptFallbackMock = vi.fn();
const generateContentMock = vi.fn();

vi.mock('@google/genai', () => ({
  GoogleGenAI: vi.fn().mockImplementation(() => ({
    models: {
      generateContent: generateContentMock,
    },
  })),
  Type: {
    ARRAY: 'ARRAY',
    OBJECT: 'OBJECT',
    STRING: 'STRING',
  },
}));

vi.mock('../videoTranscriptService', () => ({
  fetchVideoTranscript: fetchVideoTranscriptMock,
  fetchVideoTranscriptFallback: fetchVideoTranscriptFallbackMock,
}));

describe('generateInstructionsFromVideo', () => {
  beforeEach(() => {
    vi.resetModules();
    fetchVideoTranscriptMock.mockReset();
    fetchVideoTranscriptFallbackMock.mockReset();
    generateContentMock.mockReset();
    process.env.GEMINI_API_KEY = 'test-key';
  });

  afterEach(() => {
    delete process.env.GEMINI_API_KEY;
  });

  it('includes transcript chunks when available', async () => {
    fetchVideoTranscriptMock.mockResolvedValue({
      status: 'available',
      videoId: 'abc123',
      segments: [
        { text: '첫 번째 단계 안내' },
        { text: '두 번째 단계 안내' },
      ],
    });
    fetchVideoTranscriptFallbackMock.mockResolvedValue(null);

    generateContentMock.mockResolvedValue({ text: '["1. 준비", "2. 마무리"]' });

    const { generateInstructionsFromVideo } = await import('../geminiService');

    const result = await generateInstructionsFromVideo(
      {
        id: 'abc123',
        title: '테스트 영상',
        channelTitle: '채널',
        thumbnailUrl: 'thumb.jpg',
        videoUrl: 'https://www.youtube.com/watch?v=abc123',
        transcriptStatus: 'available',
      },
      ['마늘'],
      {
        recipeName: '테스트 레시피',
        description: '설명',
        instructions: ['기존 단계'],
        ingredientsNeeded: ['양파'],
      }
    );

    expect(generateContentMock).toHaveBeenCalledTimes(1);
    const request = generateContentMock.mock.calls[0]?.[0];
    expect(Array.isArray(request.contents)).toBe(true);
    expect(request.contents[0]?.parts?.length).toBeGreaterThan(1);
    expect(result.steps).toEqual(['1. 준비', '2. 마무리']);
    expect(result.transcript.status).toBe('used');
    expect(fetchVideoTranscriptFallbackMock).not.toHaveBeenCalled();
  });

  it('uses speech-to-text fallback when primary transcript is unavailable', async () => {
    fetchVideoTranscriptMock.mockResolvedValue({
      status: 'unavailable',
      videoId: 'abc123',
    });
    fetchVideoTranscriptFallbackMock.mockResolvedValue({
      status: 'autoGenerated',
      segments: [
        { text: '폴백 전사 첫 번째 문장' },
        { text: '폴백 전사 두 번째 문장' },
      ],
      reason: undefined,
    });

    generateContentMock.mockResolvedValue({ text: '["1. 준비"]' });

    const { generateInstructionsFromVideo } = await import('../geminiService');

    const result = await generateInstructionsFromVideo(
      {
        id: 'abc123',
        title: '테스트 영상',
        channelTitle: '채널',
        thumbnailUrl: 'thumb.jpg',
        videoUrl: 'https://www.youtube.com/watch?v=abc123',
        transcriptStatus: 'unknown',
      },
      [],
      {
        recipeName: '테스트 레시피',
        description: '설명',
        instructions: [],
        ingredientsNeeded: [],
      }
    );

    expect(fetchVideoTranscriptFallbackMock).toHaveBeenCalledWith('abc123');
    expect(generateContentMock).toHaveBeenCalledTimes(1);
    const request = generateContentMock.mock.calls[0]?.[0];
    expect(Array.isArray(request.contents)).toBe(true);
    expect(result.transcript.status).toBe('autoGenerated');
    expect(result.steps).toEqual(['1. 준비']);
  });

  it('falls back to metadata-only prompt when no transcripts can be retrieved', async () => {
    fetchVideoTranscriptMock.mockResolvedValue({
      status: 'unavailable',
      videoId: 'abc123',
    });
    fetchVideoTranscriptFallbackMock.mockResolvedValue({
      status: 'autoGenerated',
      segments: [],
      reason: 'speech_failed',
    });

    generateContentMock.mockResolvedValue({ text: '["1. 준비"]' });

    const { generateInstructionsFromVideo } = await import('../geminiService');

    const result = await generateInstructionsFromVideo(
      {
        id: 'abc123',
        title: '테스트 영상',
        channelTitle: '채널',
        thumbnailUrl: 'thumb.jpg',
        videoUrl: 'https://www.youtube.com/watch?v=abc123',
        transcriptStatus: 'unknown',
      },
      [],
      {
        recipeName: '테스트 레시피',
        description: '설명',
        instructions: [],
        ingredientsNeeded: [],
      }
    );

    expect(fetchVideoTranscriptFallbackMock).toHaveBeenCalledWith('abc123');
    expect(generateContentMock).toHaveBeenCalledTimes(1);
    const request = generateContentMock.mock.calls[0]?.[0];
    expect(typeof request.contents).toBe('string');
    expect(result.transcript.status).toBe('missing');
    expect(result.steps).toEqual(['1. 준비']);
  });

  it('uses fallback transcript when primary fetch fails entirely', async () => {
    fetchVideoTranscriptMock.mockRejectedValue(new Error('network error'));
    fetchVideoTranscriptFallbackMock.mockResolvedValue({
      status: 'autoGenerated',
      segments: [{ text: '폴백만 사용된 전사' }],
      reason: undefined,
    });

    generateContentMock.mockResolvedValue({ text: '["1. 준비"]' });

    const { generateInstructionsFromVideo } = await import('../geminiService');

    const result = await generateInstructionsFromVideo(
      {
        id: 'abc123',
        title: '테스트 영상',
        channelTitle: '채널',
        thumbnailUrl: 'thumb.jpg',
        videoUrl: 'https://www.youtube.com/watch?v=abc123',
        transcriptStatus: 'unknown',
      },
      [],
      {
        recipeName: '테스트 레시피',
        description: '설명',
        instructions: [],
        ingredientsNeeded: [],
      }
    );

    expect(fetchVideoTranscriptFallbackMock).toHaveBeenCalledWith('abc123');
    const request = generateContentMock.mock.calls[0]?.[0];
    expect(Array.isArray(request.contents)).toBe(true);
    expect(result.transcript.status).toBe('autoGenerated');
  });
});
