import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

const originalFetch = global.fetch;

describe('videoTranscriptService', () => {
  const fetchMock = vi.fn<Parameters<typeof fetch>, ReturnType<typeof fetch>>();

  beforeEach(() => {
    vi.resetModules();
    fetchMock.mockReset();
    global.fetch = fetchMock as unknown as typeof fetch;
    delete process.env.VIDEO_TRANSCRIPT_SERVICE_URL;
    delete process.env.VIDEO_TRANSCRIPT_FALLBACK_SERVICE_URL;
  });

  afterEach(() => {
    global.fetch = originalFetch;
  });

  it('uses fallback endpoint when the primary transcript service reports 404', async () => {
    fetchMock.mockResolvedValueOnce({
      ok: false,
      status: 404,
      statusText: 'Not Found',
      json: async () => ({ segments: [] }),
    } as unknown as Response);

    fetchMock.mockResolvedValueOnce({
      ok: true,
      status: 200,
      statusText: 'OK',
      json: async () => ({
        segments: [
          { text: '  첫 번째 문장  ', start: 0, duration: 1.2 },
          { text: '두 번째 문장', start: 1.2, duration: 1.1 },
        ],
      }),
    } as unknown as Response);

    const { fetchVideoTranscript } = await import('../videoTranscriptService');

    const result = await fetchVideoTranscript('https://www.youtube.com/watch?v=abc123xyz89');

    expect(fetchMock).toHaveBeenCalledTimes(2);
    expect(fetchMock.mock.calls[0]?.[0]).toContain('/api/transcript');
    expect(fetchMock.mock.calls[1]?.[0]).toBe('/api/transcript/fallback');
    expect(result.status).toBe('autoGenerated');
    expect(result.videoId).toBe('abc123xyz89');
    expect(result.segments).toEqual([
      { text: '첫 번째 문장', start: 0, duration: 1.2 },
      { text: '두 번째 문장', start: 1.2, duration: 1.1 },
    ]);
  });

  it('propagates fallback reason when no transcript could be generated', async () => {
    fetchMock.mockResolvedValueOnce({
      ok: true,
      status: 200,
      statusText: 'OK',
      json: async () => ({ segments: [] }),
    } as unknown as Response);

    fetchMock.mockResolvedValueOnce({
      ok: true,
      status: 200,
      statusText: 'OK',
      json: async () => ({ segments: [], reason: 'no_audio_detected' }),
    } as unknown as Response);

    const { fetchVideoTranscript } = await import('../videoTranscriptService');

    const result = await fetchVideoTranscript('abc123xyz89');

    expect(fetchMock).toHaveBeenCalledTimes(2);
    expect(result.status).toBe('unavailable');
    expect(result.reason).toBe('no_audio_detected');
  });

  it('normalizes fallback transcript segments', async () => {
    fetchMock.mockResolvedValueOnce({
      ok: true,
      status: 200,
      statusText: 'OK',
      json: async () => ({
        segments: [
          { text: '  hello world  ', start: 0, duration: 3 },
          { text: '', start: 3, duration: 1 },
        ],
        reason: 'speech_to_text',
      }),
    } as unknown as Response);

    const { fetchVideoTranscriptFallback } = await import('../videoTranscriptService');

    const fallbackResult = await fetchVideoTranscriptFallback('abc123xyz89');

    expect(fetchMock).toHaveBeenCalledWith('/api/transcript/fallback', {
      body: JSON.stringify({ videoId: 'abc123xyz89' }),
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
    });
    expect(fallbackResult?.status).toBe('autoGenerated');
    expect(fallbackResult?.segments).toEqual([{ text: 'hello world', start: 0, duration: 3 }]);
    expect(fallbackResult?.reason).toBe('speech_to_text');
  });
});
